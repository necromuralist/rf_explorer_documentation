#+TITLE: RF-Explorer Example Four - Whole spectrum, without =Dump= Method

* Description
  This is an extension of example three that tries to pull the values one at a time instead of using the =Dump= method before printing to the screen. This is probably the preferred way to do it, since it doesn't get all the extra artifacts.

* Tangle

#+BEGIN_SRC ipython :session example4 :tangle example_4.py
<<imports>>

<<main>>
<<setup-communicator>>
<<setup-loop>>
<<process-string>>
<<print-data>>
<<end-main>>

<<executable-block>>
    <<cleanup>>
#+END_SRC

* Imports
#+BEGIN_SRC ipython :session example4 :results none :noweb-ref imports
# python standard library
import argparse
import time
from datetime import datetime, timedelta

# from pypi
import RFExplorer

# this project
from example_1 import (
    argument_parser,
    Communicator,
    )
#+END_SRC

* The Main processing loop

#+BEGIN_SRC ipython :session example4 :results none :noweb-ref main
def main(arguments, communicator):
    """Runs the example

    Args:
     arguments (argparse.Namespace): object with the settings
     communicator (Communicator): object with the RFECommunicator
    """
    rf_explorer = communicator.rf_explorer
#+END_SRC

** Setup the Communicator
   This tells the communicator to do the basic setup.

#+BEGIN_SRC ipython :session example4 :results none :noweb-ref setup-communicator
    communicator.set_up()
#+END_SRC

** Setup the Loop
   The loop will run continually until we run out of time. This sets up the time variables as well as a =last_index= variable that will make sure that we only print the value if it has been updated.

#+BEGIN_SRC ipython :session example4 :results none :noweb-ref setup-loop
    print("Receiving data...")
    #Process until we complete scan time
    last_index = 0
    start = datetime.now()
    total = timedelta(seconds=arguments.run_time)
    end = start + total
    
    if arguments.csv_data:
        print("index,frequency (MHz), amplitude (dBm)")
    while (datetime.now() < end):
#+END_SRC

** Process String
   As before, the thread needs to be prompted to inspect the string it has pulled from the serial port.

#+BEGIN_SRC ipython :session example4 :results none :noweb-ref process-string
        #Process all received data from device 
        rf_explorer.ProcessReceivedString(True)
#+END_SRC

** Print The Data
   This checks the =RFExplorer.RFECommunicator.SweepData.Count= to see if it is new data and then, if it is, prints the data to the screen and then updates the =last_index= that we printed. This accesses the data directly using the :py:meth:`RFExplorer.SweepData.GetData` method. Behind the scenes this just gets the value from the =SweepData.m_arrData= list so if there's a performance problem, that might work better. The =GetData= method returns a :py:class:`RFESweepData` object, that represents one measurement (a collection of measurements, one for each frequency).

Also see :py:meth:`RFESweepData.SaveFileCSV`. For the time-stamp I'm using :py:attr:`RFESweepData.CaptureTime`, which is a :py:class:`datetime.datetime` object. It appears to be an alias for =RFESweepData.m_Time=.

#+BEGIN_SRC ipython :session example4 :results none :noweb-ref print-data
        #Print data if received new sweep only
        if (rf_explorer.SweepData.Count > last_index):
            for index in range(rf_explorer.SweepData.Count):
                data = rf_explorer.SweepData.GetData(index)
                try:
                    output = ','.join(("{:04.1f}".format(data.GetAmplitudeDBM(step, None, False))
                                                         for step in range(data.TotalSteps)))
                    print("{},{}".format(data.CaptureTime, output))
                except TypeError as error:
                    print(error)
                    print("Index: {}".format(index))
                    print("Data: {}".format(data))
                    raise
            last_index = rf_explorer.SweepData.Count          
#+END_SRC

** End Main
#+BEGIN_SRC ipython :session example4 :results none :noweb-ref end-main    
    return
#+END_SRC


* The Executable Block

#+BEGIN_SRC ipython :session example4 :results none :noweb-ref executable-block
if __name__ == "__main__":
    parser = argument_parser()
    arguments = parser.parse_args()

    with Communicator(arguments.serialport, arguments.baud_rate) as communicator:        
        main(arguments, communicator)
#+END_SRC
