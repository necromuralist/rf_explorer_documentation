RF-Explorer Example One - Peak Values
=====================================

.. contents::


1 Description
-------------

This is the first example that comes with the ``RFExplorer`` repository.
It will display the amplitude (in dBm) and the frequency (in MHz) of the frequency that had the highest amplitude in the sweep data. It runs until the amount of time allocated runs out.

2 Tangle
--------

.. code:: ipython

    <<imports>>

    <<line-formats>>

    <<print-peak>>
        <<get-data>>
        <<get-peak-data>>
    <<global-variables>>

    <<communicator>>

    <<main>>
            <<get-ports>>

            <<connect-port>>

            <<reset-explorer>>

            <<get-model>>

            <<analyzer-check>>

            <<setup-loop>>
                <<process-string>>
                <<print-data>>
        <<end-main>>

    <<argument-parser>>
        <<serial-port>>
        <<baud-rate>>
        <<run-time>>
        <<csv-data>>
        <<return-arguments>>

    <<executable-block>>
        <<cleanup>>

3 Imports
---------

.. code:: ipython

    # python standard library
    import argparse
    import time
    from datetime import datetime, timedelta

    # from pypi
    import RFExplorer

4 Print Peak
------------

This is a helper function to get only the peak data from the sweep and print it to stdout.

4.1 Line Formats
~~~~~~~~~~~~~~~~

These are the output formats for each line.

.. code:: ipython

    CSV_LINE = "{0},{1},{2}"
    HUMAN_LINE = "Sweep[{0}]: Peak: {1:.3f} MHz\t{2} dBm"

.. code:: ipython

    def PrintPeak(rf_explorer, csv_data=False):
        """This function prints the amplitude and frequency peak of the latest received sweep

        Args:
         rfe_explorer (`RFExplorer.RFECommunicator`): communicator to get data from
         csv_data (bool): if True, print as CSV output
        """

4.2 Get The Data
~~~~~~~~~~~~~~~~

This gets the current data-count from :py:attr:`RFExplorer.RFESweepDataCollection.RFESweepDataCollection.Count`, decrements it to get the current index, then gets the data from :py:meth:`RFExplorer.RFESweepDataCollection.RFESweepDataCollection.GetData`.

.. code:: ipython

    index = rf_explorer.SweepData.Count - 1
    sweep_data = rf_explorer.SweepData.GetData(index)

The ``sweep_data`` is an instance of :py:class:`RFExplorer.RFESweepData.RFESweepData`.

4.3 Get The Peak Data
~~~~~~~~~~~~~~~~~~~~~

In this case we aren't printing all the data, just the peak (the frequency that had the largest amplitude).

 * :py:meth:`RFExplorer.RFESweepData.RFESweepData.GetPeakStep`
 * :py:meth:`RFExplorer.RFESweepData.RFESweepData.GetAmplitude_DBM`
 * :py:meth:`RFExplorer.RFESweepData.RFESweepData.GetFrequencyMHZ`

.. code:: ipython

    peak_step = sweep_data.GetPeakStep()      #Get index of the peak
    peak_amplitude = sweep_data.GetAmplitude_DBM(peak_step)    #Get amplitude of the peak
    peak_frequency = sweep_data.GetFrequencyMHZ(peak_step)   #Get frequency of the peak

    line = CSV_LINE if csv_data else HUMAN_LINE

    print(line.format(index, peak_frequency, peak_amplitude)) 
    return

5 The Communicator
------------------

This is a class to hold the :py:class:`RFExplorer.RFECommunicator` object to make it easier to remember to close it (use :py3:ref:`with`).

.. code:: ipython

    class Communicator(object):
        """holds the communication object
        """
        def __init__(self):
            self._rfe = None
            return

        @property
        def rfe(self):
            """RFE Communicator
            Returns:
             :py:class:`RFExplorer.RFECommunicator`: the communicator
            """
            if self._rfe is None:
                self._rfe = RFExplorer.RFECommunicator()
            return self._rfe

        def __enter__(self):
            """returns this object"""
            return self


        def __exit__(self, exc_type, exc_value, traceback):
            self.close()
            return

        def __del__(self):
            """closes the RFECommunicator"""
            self.close()

        def close(self):
            """Closes the RFECommunicator
        
            Side-Effect:
             calls `RFExplorer.RFECommunicator.Close`
            """
            if self._rfe is not None:
                self.rfe.Close()
                self._rfe = None
            return

6 The Main processing loop
--------------------------

.. code:: ipython

    def main(arguments, communicator):
        """Runs the example

        Args:
         arguments (argparse.Namespace): object with the settings
         communicator (Communicator): object with the RFECommunicator
        """
        rf_explorer = communicator.rfe
        try:

6.1 Get the ports
~~~~~~~~~~~~~~~~~

The :py:meth:`RFExplorer.RFECommunicator.GetConnectedPorts` method will gather what it thinks are possible ports that the RF-Explorer might be attached to. As a side-effect it will print the ports it found to stdout.

.. code:: ipython

    # get candidate serial ports and print out what you discovered
    rf_explorer.GetConnectedPorts()

6.2 Connect to the RFExplorer
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The :py:meth:`RFExplorer.RFECommunicator.ConnectPort` will try to connect to the RFExplorer. If ``arguments.serialport`` is ``None`` then it will try each candidate port in order. On my desktop this currently fails (I think because it tries ``/dev/ttyS4`` first) so I have to pass in ``/dev/ttyUSB0`` explicitly to make it work.

.. code:: ipython

    #Connect to available port
    if (not rf_explorer.ConnectPort(arguments.serialport, arguments.baud_rate)):
        print("Not Connected")
        return

6.3 Reset The Device
~~~~~~~~~~~~~~~~~~~~

This sends the reset command ("r") using :py:meth:`RFExplorer.RFECommunicator.SendCommand`, then waits forever for the :py:attr:`RFExplorer.RFECommunicator.IsResetEvent` attribute to change to False. Once the device indicates that it is out of the reset-state it sleeps for three seconds to let things settle down.

.. code:: ipython

    #Reset the unit to start fresh
    print("sending the Reset Command")
    rf_explorer.SendCommand("r")

    #Wait for unit to notify reset completed
    print("Waiting until the device resets")
    while(rf_explorer.IsResetEvent):
        pass

    #Wait for unit to stabilize
    print("Reset, sleeping for 3 seconds")
    time.sleep(3)

6.4 The Model And Configuration
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Most of the methods you want to use assume that the configuration has been set up. This loop makes the request to set it up and then waits forever for the model to be set (waits for :py:attr:`RFExplorer.RFECommunicator.ActiveModel` to not equal :py:obj:`RFExplorer.RFE_Common.eModel.MODEL_NONE`). The ``RFExplorer`` has to be prompted to process the information that the thread is reading off the serial port so in between checking if the model is set it calls :py:meth:`RFExplorer.RFECommunicator.ProcessReceivedString` to tell it to do so (passing in ``True`` tells it to process all the strings it has, not just one).

.. code:: ipython

    #Request RF Explorer configuration
    print("requesting the configuration data")
    rf_explorer.SendCommand_RequestConfigData()
    #Wait to receive configuration and model details
    print("Waiting for the model to not be None")
    while(rf_explorer.ActiveModel == RFExplorer.RFE_Common.eModel.MODEL_NONE):
        rf_explorer.ProcessReceivedString(True)    #Process the received configuration

    print("Model is set")

6.5 Analyzer Check
~~~~~~~~~~~~~~~~~~

The ``RFExplorer`` can talk to both spectrum analyzers and signal generators, but this code will only work with the spectrum analyzer, so use the :py:meth:`RFExplorer.RFECommunicator.IsAnalyzer` method to make sure that's what this is.

.. code:: ipython

    #If object is an analyzer, we can scan for received sweeps
    if (not rf_explorer.IsAnalyzer()):     
        print("Error: Device connected is a Signal Generator. "
              "\nPlease, connect a Spectrum Analyzer")
        return

6.6 Setup the Loop
~~~~~~~~~~~~~~~~~~

The loop will run continually until we run out of time. This sets up the time variables as well as a ``last_index`` variable that will make sure that we only print the value if it has been updated.

.. code:: ipython

    print("Receiving data...")
    #Process until we complete scan time
    last_index = 0
    start = datetime.now()
    total = timedelta(seconds=arguments.run_time)
    end = start + total

    if arguments.csv_data:
        print("index,frequency (MHz), amplitude (dBm)")
    while (datetime.now() < end):

6.7 Process String
~~~~~~~~~~~~~~~~~~

As before, the thread needs to be prompted to inspect the strings it has pulled from the serial port.

.. code:: ipython

    #Process all received data from device 
    rf_explorer.ProcessReceivedString(True)

6.8 Print The Data
~~~~~~~~~~~~~~~~~~

This checks the ``SweepData`` count (:py:attr:`RFExplorer.RFESweepDataCollection.RFESweepDataCollection.Count`) to see if it is new data and then, if it is, calls the ``PrintPeak`` function (defined above) to print the data to the screen, and then updates the ``last_index`` that we printed.

.. code:: ipython

    #Print data if received new sweep only
    if (rf_explorer.SweepData.Count > last_index):
        PrintPeak(rf_explorer, arguments.csv_data)
        last_index = rf_explorer.SweepData.Count          

6.9 End Main
~~~~~~~~~~~~

This is a leftover block to catch any exceptions that get raised.

.. code:: ipython

    except Exception as error:
        print("Error: {}".format(obEx))
    return

7 The Argument Parser
---------------------

This creates the command-line interface for the example using :py:class:`argparse <argparse.ArgumentParser>`.

.. code:: ipython

    def parse_arguments():
        parser = argparse.ArgumentParser("RF Explorer Example One")

7.1 Serial Port
~~~~~~~~~~~~~~~

If the :py:meth:`RFExplorer.RFECommunicator.ConnectPort` isn't given a serial port it will try all the likely ports until it does or doesn't connect. If this doesn't work then pass in a specific port (e.g. ``/dev/ttyUSB0``).

.. code:: ipython

    parser.add_argument(
        "--serialport", type=str,
        help="Path to the serial-port file (e.g. '/dev/ttyUSB0') - Default=%(default)s")

7.2 Baud Rate
~~~~~~~~~~~~~

The baud-rate should be 500,000, but if it's not, then you can change it here.

.. code:: ipython

    parser.add_argument(
        "--baud-rate", type=int, default=500000,
        help="Baud-rate for the serial port (default=%(default)s)")

7.3 Run-Time
~~~~~~~~~~~~

This is the number of seconds to collect data before quitting.

.. code:: ipython

    parser.add_argument(
        "--run-time", type=int, default=10,
        help="Seconds to collect data (default=%(default)s)"
    )

7.4 CSV Data
~~~~~~~~~~~~

This tells the code to print a CSV format instead of the usual (human-readable) format. Some of the print statements come from the ``RFExplorer for python`` so you will probably still have to clean things up afterwards.

.. code:: ipython

    parser.add_argument(
        "--csv-data", action="store_true",
        help="Output csv-formatted data",
    )

7.5 Parse the Arguments
~~~~~~~~~~~~~~~~~~~~~~~

.. code:: ipython

    return parser.parse_args()

8 The Executable Block
----------------------

.. code:: ipython

    if __name__ == "__main__":
        arguments = parse_arguments()
        with Communicator() as communicator:        
            main(arguments, communicator)
